/**
 * FILE: CommandMessage.proto
 * BRIEF: Command messages are used to send commands to any boards. These messages are sent from the ground to the rocket.
 * AUTHOR: Christopher Chan (cjchanx)
 */
syntax = "proto3";
package Proto;
import "CoreProto.proto";

/* Command Message ------------------------------------------------------------------*/
/* This acts as the command wrapper message for all SOAR Command Messages. This message is used to send commands to any board.
 *
 * The message path is defined by the source and target fields. The source field is the node that sent the message, the target field is the node that the message is intended for.
 * If the target field is set to NODE_ANY, then the message is a broadcast message and should be sent to all nodes.
 *
 * Note that all Command Messages should be ACKed by the target node. If the target node does not ACK the message, the source node should resend the message.
 */
message CommandMessage {
    // Message Path
    Node source = 1; // This is the source of the message (the node that sent the message)
    Node target = 2; // This is the destination of the message, if this is a broadcast message, this should be set to NODE_ANY

    // Message Identifiers
    MessageID message_id = 3; // This is the message ID of the message, this is used to identify the message type

    /* There are much more robust RDT implementations, but for simplicity, we will use a sequence number simply to verify
     * ACKs are for the correct respective message. Each SOURCE node maintains a counting UINT32_T that is incremented for EVERY
     * message send to ANY source (if we want to make this more robust, we can use a unique sequence number per message path but that
     * would require an N_NODES array of sequence numbers which is not necessary for our purposes).
     */
    uint32 source_sequence_num = 4; // This is the sequence number of the message, should start at (1), if its 0 it does not need to be ACKed (ie. Non-essential Telemetry)

    // Message Data
    oneof message {
        // Command Messages
        DMBCommand dmb_command = 5;
        PBBCommand pbb_command = 6;
        RCUCommand rcu_command = 7;
        SOBCommand sob_command = 8;
    }

}

message DMBCommand {
    enum Command {
        RSC_FIRST_INVALID = 0;

        RSC_ANY_TO_ABORT = 1;       // Transition to ABORT state - available from all states except for IGNITION/LAUNCH/BURN
        RSC_OPEN_VENT = 2;   // Open the vent valve
        RSC_CLOSE_VENT = 3;  // Close the vent valve
        RSC_OPEN_DRAIN = 4; // Open the drain valve
        RSC_CLOSE_DRAIN = 5; // Close the drain valve
        RSC_MEV_CLOSE = 6;   // Forces MEV to close - ONLY supported in states where it is safe to close the MEV

        //-- PRELAUNCH --
        RSC_GOTO_FILL = 7; // Transition to the FILL state

        //-- FILL --
        RSC_ARM_CONFIRM_1 = 8;   // Enable first ARM confirmation flag
        RSC_ARM_CONFIRM_2 = 9;   // Enable second ARM confirmation flag
        RSC_GOTO_ARM = 10;      // Transition to the ARM state (not allowed without the confirm flags set)
        RSC_GOTO_PRELAUNCH = 11; // Transition to the PRELAUNCH state from FILL

        //-- ARM/IGNITION/LAUNCH/BURN --

        //-- ARM --
        RSC_POWER_TRANSITION_ONBOARD = 12;      // Change power source to onboard
        RSC_POWER_TRANSITION_EXTERNAL = 13;     // Change power source to external power
        //RSC_GOTO_FILL, // Transition back
        RSC_GOTO_IGNITION = 14; // Ready for ignition sequence - Transition to IGNITION state

        //-- IGNITION --
        RSC_IGNITION_TO_LAUNCH = 15;   // Confirm igniter actuation - Transition to LAUNCH state (MEV OPEN)
        //RSC_GOTO_ARM      // Non-confirm igniter actuation - Transition back to ARM state   

        //-- LAUNCH --
        // * These flight sequence commands can be replaced with direct calls to transition state IF possible
        RSC_LAUNCH_TO_BURN = 16; // Internal command, should not be triggered externally
        //-- BURN --
        RSC_BURN_TO_COAST = 17; // Internal command, should not be triggered externally
        //-- COAST --
        RSC_COAST_TO_DESCENT = 18; // Internal command, should not be triggered externally
        //-- DESCENT --
        RSC_DESCENT_TO_RECOVERY = 19; // Internal command, should not be triggered externally

        //-- ABORT --
        //RSC_GOTO_PRELAUNCH, // Confirm transition back into prelaunch state

        //-- GENERAL --

        //-- TECHNICAL --
        RSC_NONE = 20;  // Invalid command, must be last
    }
    
    Command command_enum = 1;
}

message PBBCommand {
    enum Command {
        PBB_NONE = 0;

        PBB_OPEN_MEV = 1;
        PBB_CLOSE_MEV = 2;
        PBB_OPEN_DRAIN = 3;
        PBB_CLOSE_DRAIN = 4;

        PMB_LAST = 5;
    }
    
    Command command_enum = 1;
}

message SOBCommand {
    enum Command {
        SOB_NONE = 0;

        SOB_SLOW_SAMPLE_IR = 1;
        SOB_FAST_SAMPLE_IR = 2;
        SOB_TARE_LOAD_CELL = 3;
        SOB_CALIBRATE_LOAD_CELL = 4;

        SOB_LAST = 5;
    }
    
    Command command_enum = 1;
    int32 command_param = 2; //for mass calibration
}

message RCUCommand {
    enum Command {
        RCU_NONE = 0;

        RCU_TARE_LOAD_CELL = 1;
        RCU_CALIBRATE_LOAD_CELL = 2;

        RCU_OPEN_AC1 = 3;
        RCU_CLOSE_AC1 = 4;
        RCU_OPEN_AC2 = 5;
        RCU_CLOSE_AC2 = 6;
        RCU_OPEN_PBV1 = 7;
        RCU_CLOSE_PBV1 = 8;
        RCU_OPEN_PBV2 = 9;
        RCU_CLOSE_PBV2 = 10;
        RCU_OPEN_PBV3 = 11;
        RCU_CLOSE_PBV3 = 12;
        RCU_OPEN_SOL1 = 13;
        RCU_CLOSE_SOL1 = 14;
        RCU_OPEN_SOL2 = 15;
        RCU_CLOSE_SOL2 = 16;
        RCU_OPEN_SOL3 = 17;
        RCU_CLOSE_SOL3 = 18;
        RCU_OPEN_SOL4 = 19;
        RCU_CLOSE_SOL4 = 20;
        RCU_OPEN_SOL5 = 21;
        RCU_CLOSE_SOL5 = 22;
        RCU_OPEN_SOL6 = 23;
        RCU_CLOSE_SOL6 = 24;
        RCU_OPEN_SOL7 = 25;
        RCU_CLOSE_SOL7 = 26;
        RCU_OPEN_SOL8A = 27;
        RCU_CLOSE_SOL8A = 28;
        RCU_OPEN_SOL8B = 29;
        RCU_CLOSE_SOL8B = 30;

        RCU_IGNITE_PAD_BOX1 = 31; //may be unused
        RCU_IGNITE_PAD_BOX2 = 32;

        RCU_LAST = 33;
    }
    
    Command command_enum = 1;
    int32 command_param = 2; //for mass calibration
}